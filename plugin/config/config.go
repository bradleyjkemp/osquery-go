// Package config creates an osquery configuration plugin.
//
// See https://osquery.readthedocs.io/en/latest/development/config-plugins/ for more.
package config

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/kolide/osquery-go/gen/osquery"
)

// GenerateConfigsFunc returns the configurations generated by this plugin.
// The returned map should use the source name as key, and the config
// JSON as values. The context argument can optionally be used for
// cancellation in long-running operations.
type GenerateConfigsFunc func(ctx context.Context) (map[string]Config, error)

type Config struct {
	Options               map[string]interface{}           `json:"options,omitempty"`
	Schedule              map[string]Query                 `json:"schedule,omitempty"`
	Packs                 map[string]Pack                  `json:"packs,omitempty"`
	AutoTableConstruction map[string]AutoTableConstruction `json:"auto_table_construction,omitempty"`
	Decorators            *struct {
		Always []string `json:"always,omitempty"`
		Load   []string `json:"load,omitempty"`
	} `json:"decorators,omitempty"`
}

type Query struct {
	Query    string `json:"query"`
	Interval int    `json:"interval"`
	Snapshot bool   `json:"snapshot,omitempty"`
	// TODO: IncludeRemoved bool   `json:"removed,omitempty"`
}

type Pack struct {
	Queries map[string]Query `json:"queries"`
}

type AutoTableConstruction struct {
	Columns  []string `json:"columns"`
	Path     string   `json:"path"`
	Platform string   `json:"platform"`
	Query    string   `json:"query"`
}

// Plugin is an osquery configuration plugin. Plugin implements the OsqueryPlugin
// interface.
type Plugin struct {
	name     string
	generate GenerateConfigsFunc
}

// NewConfigPlugin takes a value that implements ConfigPlugin and wraps it with
// the appropriate methods to satisfy the OsqueryPlugin interface. Use this to
// easily create configuration plugins.
func NewPlugin(name string, fn GenerateConfigsFunc) *Plugin {
	return &Plugin{name: name, generate: fn}
}

func (t *Plugin) Name() string {
	return t.name
}

// Registry name for config plugins
const configRegistryName = "config"

func (t *Plugin) RegistryName() string {
	return configRegistryName
}

func (t *Plugin) Routes() osquery.ExtensionPluginResponse {
	return osquery.ExtensionPluginResponse{}
}

func (t *Plugin) Ping(ctx context.Context) osquery.ExtensionStatus {
	return osquery.ExtensionStatus{Code: 0, Message: "OK"}
}

// Key that the request method is stored under
const requestActionKey = "action"

// Action value used when config is requested
const genConfigAction = "genConfig"

func (t *Plugin) Call(ctx context.Context, request osquery.ExtensionPluginRequest) (osquery.ExtensionPluginResponse, error) {
	switch request[requestActionKey] {
	case genConfigAction:
		configs, err := t.generate(ctx)
		if err != nil {
			return nil, fmt.Errorf("error getting config: %w", err)
		}

		resp := map[string]string{}
		for source, config := range configs {
			c, _ := json.Marshal(config)
			resp[source] = string(c)
		}

		return osquery.ExtensionPluginResponse{resp}, nil

	default:
		return nil, fmt.Errorf("unknown action: %s", request["action"])

	}

}

func (t *Plugin) Shutdown() {}
